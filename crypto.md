# Paprika 3 Cryptographic Implementation

The Paprika 3 application employs a cryptographic system to protect license data stored locally and authenticate with its cloud services. This system combines symmetric encryption for local data protection with asymmetric cryptography for server authentication, ensuring that only legitimate users can access cloud services.

## Local License Data Encryption

Paprika 3 stores license information in an SQLite database within the `purchases` table, specifically in the `data` and `signature` columns. Both fields contain encrypted information that must be decrypted to understand the user's license status and authenticate with Paprika's servers.

The encryption process begins with the preparation of plaintext data. The `data` field contains a JSON string representing the user's license information in the following format:

```json
{
  "key": "LICENSE-KEY-HERE",
  "name": "User Name",
  "email": "user@example.com", 
  "product_id": "com.hindsightlabs.paprika.windows.v3",
  "purchase_date": "2025-07-14 20:09:31",
  "disabled": false,
  "refunded": false,
  "install_uid": "device-identifier-here",
  "algorithm": 1
}
```

The `signature` field contains a Base64-encoded RSA digital signature that validates the authenticity of this license data. This RSA signature is generated by Paprika's servers during the original license creation process using Paprika's private RSA key (which is not available to end users).

Both of these plaintext values are encrypted using the same symmetric encryption algorithm but with different encryption keys.

The core encryption algorithm utilizes the Advanced Encryption Standard (AES) in Cipher Block Chaining (CBC) mode with a 256-bit key size. This symmetric encryption is combined with the Password-Based Key Derivation Function 2 (PBKDF2) to transform user-friendly encryption keys into cryptographically secure encryption materials.

The PBKDF2 implementation uses the SHA-1 hash algorithm and performs exactly 1000 rounds of hashing to derive the encryption key and initialization vector (IV). The salt used in this process is a 32-byte value that is generated randomly when the data is first encrypted. For any given installation, this salt remains fixed for the lifetime of that specific encrypted value but will be different from other installations and different between the data and signature fields within the same installation. This salt is prepended to the resulting ciphertext, making the encrypted data self-contained and eliminating the need to store the salt separately.

The key derivation process produces 48 bytes of material through the PBKDF2 function: PBKDF2(password, salt, 1000, SHA-1) â†’ 48 bytes. These 48 bytes are then split into two components: the first 32 bytes serve as the AES-256 encryption key, and the next 16 bytes (bytes 33-48) serve as the 128-bit initialization vector for CBC mode operation. Any remaining bytes are discarded.

Before encryption, the plaintext data undergoes UTF-8 encoding to convert it into a byte array suitable for the AES algorithm. After encryption, the data is padded using PKCS#7 padding scheme to ensure the plaintext length is a multiple of the AES block size (16 bytes). This padding is automatically removed during the decryption process.

The final encrypted format consists of the 32-byte salt concatenated with the AES-encrypted ciphertext. This combined result is then Base64-encoded for storage in the SQLite database.

## Decryption Process

To decrypt the license data, the process is reversed. First, the Base64-encoded string is decoded to recover the binary encrypted data. The first 32 bytes are extracted as the salt, and the remaining bytes constitute the ciphertext.

The PBKDF2 function is then executed using the extracted salt, the appropriate encryption key (either "Purchase Data" for the license JSON or "Purchase Signature" for the RSA signature), and exactly 1000 iterations with the SHA-1 hash algorithm. This produces the same 48-byte key material that was used during encryption.

The AES-256 decryption is performed in CBC mode using the first 32 bytes as the key and the next 16 bytes as the IV. After decryption, the PKCS#7 padding is removed by examining the final byte of the decrypted data, which indicates the number of padding bytes that were added. These padding bytes are then stripped away to recover the original UTF-8 encoded plaintext.

Finally, the UTF-8 byte array is decoded back into a string, revealing either the JSON license data or the RSA signature, depending on which field was decrypted.

## Server Authentication Cryptography

The server authentication process requires both the decrypted license data and the decrypted RSA signature. The license data must be a valid JSON structure containing the user's license information, and the RSA signature must be a valid cryptographic signature of this license data using Paprika's private key (which was used by Paprika's servers during original license creation).

When authenticating with the server, a multipart form POST request is sent to `https://www.paprikaapp.com/api/v2/account/login/`. This request contains four fields: `email` (user's account email), `password` (user's account password), `data` (the decrypted license JSON), and `signature` (the decrypted RSA signature as a string, which the server will validate using Paprika's public key).

The Paprika server validates this authentication request by first verifying the RSA signature against the provided license data using Paprika's public key. This ensures that the license data has not been tampered with and was issued by Paprika. The server then validates that the license is active (not expired or refunded) and matches the device ID of the requesting client.

If all validations pass, the server generates a JSON Web Token (JWT) and returns it in the response. This JWT token is then used for all subsequent API requests to authenticate the user and authorize access to their recipe data.

This cryptographic system ensures that only legitimate Paprika license holders can access the cloud services, while the local encryption protects sensitive license information from unauthorized access on the user's device. The RSA signature component prevents users from creating or modifying their own license data, as they would not have access to Paprika's private key required to generate valid signatures.